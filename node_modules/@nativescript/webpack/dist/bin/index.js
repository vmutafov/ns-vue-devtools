#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const commander_1 = require("commander");
const ts_dedent_1 = __importDefault(require("ts-dedent"));
const webpack_1 = __importDefault(require("webpack"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const parseEnvFlags_1 = require("../cli/parseEnvFlags");
const defaultConfig = path_1.default.resolve(__dirname, '../stubs/default.config.stub.js');
const tag = `[${chalk_1.green('@nativescript/webpack')}]`;
function error(message) {
    console.error(`${tag} ${chalk_1.redBright(ts_dedent_1.default(message))}`);
}
function info(message) {
    console.info(`${tag} ${chalk_1.greenBright(ts_dedent_1.default(message))}`);
}
commander_1.program.enablePositionalOptions();
commander_1.program
    .command('init')
    .description('Initialize a new webpack.config.js in the current directory.')
    .action(() => {
    const targetPath = path_1.default.resolve(process.cwd(), 'webpack.config.js');
    if (fs_1.default.existsSync(targetPath)) {
        return error(`File Already Exists: ${targetPath}`);
    }
    fs_1.default.copyFileSync(defaultConfig, targetPath);
    info('Initialized config.');
});
commander_1.program
    .command('build')
    .description('Build...')
    .option('--env [name]', 'environment name')
    .option('--config [path]', 'config path')
    .option('--watch', 'watch for changes')
    .allowUnknownOption()
    .action((options, command) => {
    var _a;
    const env = parseEnvFlags_1.parseEnvFlags(command.args);
    // add --env <val> into the env object
    // for example if we use --env prod
    // we'd have env.env = 'prod'
    if (options.env) {
        env['env'] = options.env;
    }
    const configPath = (() => {
        if (options.config) {
            return path_1.default.resolve(options.config);
        }
        return path_1.default.resolve(process.cwd(), 'webpack.config.js');
    })();
    // todo: validate config exists
    // todo: guard against invalid config
    let configuration;
    try {
        configuration = require(configPath)(env);
    }
    catch (err) {
        console.log(err);
    }
    if (!configuration) {
        console.log('No configuration!');
        return;
    }
    const compiler = webpack_1.default(configuration);
    const webpackCompilationCallback = (err, stats) => {
        if (err) {
            // Do not keep cache anymore
            compiler.purgeInputFileSystem();
            console.error(err.stack || err);
            if (err.details) {
                console.error(err.details);
            }
            process.exitCode = 1;
            return;
        }
        if (stats) {
            console.log(stats.toString({
                chunks: false,
                colors: true,
                errorDetails: env.verbose,
            }));
        }
    };
    if (options.watch) {
        console.log('webpack is watching the files...');
        compiler.watch((_a = configuration.watchOptions) !== null && _a !== void 0 ? _a : {}, webpackCompilationCallback);
    }
    else {
        compiler.run(webpackCompilationCallback);
    }
});
commander_1.program.parse(process.argv);
//# sourceMappingURL=index.js.map
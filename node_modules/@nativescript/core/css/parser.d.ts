export declare type Parsed<V> = {
    start: number;
    end: number;
    value: V;
};
export declare type ARGB = number;
export declare type URL = string;
export declare type Angle = number;
export interface Unit<T> {
    value: number;
    unit: string;
}
export declare type Length = Unit<'px' | 'dip'>;
export declare type Percentage = Unit<'%'>;
export declare type LengthPercentage = Length | Percentage;
export declare type Keyword = string;
export interface ColorStop {
    argb: ARGB;
    offset?: LengthPercentage;
}
export interface LinearGradient {
    angle: number;
    colors: ColorStop[];
}
export interface Background {
    readonly color?: number;
    readonly image?: URL | LinearGradient;
    readonly repeat?: BackgroundRepeat;
    readonly position?: BackgroundPosition;
    readonly size?: BackgroundSize;
}
export declare type BackgroundRepeat = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';
export declare type BackgroundSize = 'auto' | 'cover' | 'contain' | {
    x: LengthPercentage;
    y: 'auto' | LengthPercentage;
};
export declare type HorizontalAlign = 'left' | 'center' | 'right';
export declare type VerticalAlign = 'top' | 'center' | 'bottom';
export interface HorizontalAlignWithOffset {
    readonly align: 'left' | 'right';
    readonly offset: LengthPercentage;
}
export interface VerticalAlignWithOffset {
    readonly align: 'top' | 'bottom';
    readonly offset: LengthPercentage;
}
export interface BackgroundPosition {
    readonly x: HorizontalAlign | HorizontalAlignWithOffset;
    readonly y: VerticalAlign | VerticalAlignWithOffset;
    text?: string;
}
export declare function parseURL(text: string, start?: number): Parsed<URL>;
export declare function parseHexColor(text: string, start?: number): Parsed<ARGB>;
export declare function parseRGBColor(text: string, start?: number): Parsed<ARGB>;
export declare function parseRGBAColor(text: string, start?: number): Parsed<ARGB>;
export declare function convertHSLToRGBColor(hue: number, saturation: number, lightness: number): {
    r: number;
    g: number;
    b: number;
};
export declare function parseHSLColor(text: string, start?: number): Parsed<ARGB>;
export declare function parseHSLAColor(text: string, start?: number): Parsed<ARGB>;
export declare function parseColorKeyword(value: any, start: number, keyword?: Parsed<string>): Parsed<ARGB>;
export declare function parseColor(value: string, start?: number, keyword?: Parsed<string>): Parsed<ARGB>;
export declare function parseRepeat(value: string, start?: number, keyword?: Parsed<string>): Parsed<BackgroundRepeat>;
export declare function parseUnit(text: string, start?: number): Parsed<Unit<string>>;
export declare function parsePercentageOrLength(text: string, start?: number): Parsed<LengthPercentage>;
export declare function parseAngle(value: string, start?: number): Parsed<Angle>;
export declare function parseBackgroundSize(value: string, start?: number, keyword?: Parsed<string>): Parsed<BackgroundSize>;
export declare function parseBackgroundPosition(text: string, start?: number, keyword?: Parsed<string>): Parsed<BackgroundPosition>;
export declare function parseColorStop(text: string, start?: number): Parsed<ColorStop>;
export declare function parseLinearGradient(text: string, start?: number): Parsed<LinearGradient>;
export declare function parseBackground(text: string, start?: number): Parsed<Background>;
export declare type Combinator = '+' | '~' | '>' | ' ';
export interface UniversalSelector {
    type: '*';
}
export interface TypeSelector {
    type: '';
    identifier: string;
}
export interface ClassSelector {
    type: '.';
    identifier: string;
}
export interface IdSelector {
    type: '#';
    identifier: string;
}
export interface PseudoClassSelector {
    type: ':';
    identifier: string;
}
export declare type AttributeSelectorTest = '=' | '^=' | '$=' | '*=' | '~=' | '|=';
export interface AttributeSelector {
    type: '[]';
    property: string;
    test?: AttributeSelectorTest;
    value?: string;
}
export declare type SimpleSelector = UniversalSelector | TypeSelector | ClassSelector | IdSelector | PseudoClassSelector | AttributeSelector;
export declare type SimpleSelectorSequence = SimpleSelector[];
export declare type SelectorCombinatorPair = [SimpleSelectorSequence, Combinator];
export declare type Selector = SelectorCombinatorPair[];
export declare function parseUniversalSelector(text: string, start?: number): Parsed<UniversalSelector>;
export declare function parseSimpleIdentifierSelector(text: string, start?: number): Parsed<TypeSelector | ClassSelector | IdSelector | PseudoClassSelector>;
export declare function parseAttributeSelector(text: string, start: number): Parsed<AttributeSelector>;
export declare function parseSimpleSelector(text: string, start?: number): Parsed<SimpleSelector>;
export declare function parseSimpleSelectorSequence(text: string, start: number): Parsed<SimpleSelector[]>;
export declare function parseCombinator(text: string, start?: number): Parsed<Combinator>;
export declare function parseSelector(text: string, start?: number): Parsed<Selector>;
export interface Stylesheet {
    rules: Rule[];
}
export declare type Rule = QualifiedRule | AtRule;
export interface AtRule {
    type: 'at-rule';
    name: string;
    prelude: InputToken[];
    block: SimpleBlock;
}
export interface QualifiedRule {
    type: 'qualified-rule';
    prelude: InputToken[];
    block: SimpleBlock;
}
declare type InputToken = '(' | ')' | '{' | '}' | '[' | ']' | ':' | ';' | ',' | ' ' | '^=' | '|=' | '$=' | '*=' | '~=' | '<!--' | '-->' | undefined | /* <EOF-token> */ InputTokenObject | FunctionInputToken | FunctionToken | SimpleBlock | AtKeywordToken;
export declare const enum TokenObjectType {
    /**
     * <string-token>
     */
    string = 1,
    /**
     * <delim-token>
     */
    delim = 2,
    /**
     * <number-token>
     */
    number = 3,
    /**
     * <percentage-token>
     */
    percentage = 4,
    /**
     * <dimension-token>
     */
    dimension = 5,
    /**
     * <ident-token>
     */
    ident = 6,
    /**
     * <url-token>
     */
    url = 7,
    /**
     * <function-token>
     * This is a token indicating a function's leading: <ident-token>(
     */
    functionToken = 8,
    /**
     * <simple-block>
     */
    simpleBlock = 9,
    /**
     * <comment-token>
     */
    comment = 10,
    /**
     * <at-keyword-token>
     */
    atKeyword = 11,
    /**
     * <hash-token>
     */
    hash = 12,
    /**
     * <function>
     * This is a complete consumed function: <function-token>([<component-value> [, <component-value>]*])")"
     */
    function = 14
}
interface InputTokenObject {
    type: TokenObjectType;
    text: string;
}
/**
 * This is a "<ident>(" token.
 */
interface FunctionInputToken extends InputTokenObject {
    name: string;
}
/**
 * This is a completely parsed function like "<ident>([component [, component]*])".
 */
interface FunctionToken extends FunctionInputToken {
    components: any[];
}
interface SimpleBlock extends InputTokenObject {
    associatedToken: InputToken;
    values: InputToken[];
}
declare type AtKeywordToken = InputTokenObject;
/**
 * CSS parser following relatively close:
 * CSS Syntax Module Level 3
 * https://www.w3.org/TR/css-syntax-3/
 */
export declare class CSS3Parser {
    private text;
    private nextInputCodePointIndex;
    private reconsumedInputToken;
    private topLevelFlag;
    constructor(text: string);
    /**
     * For testing purposes.
     * This method allows us to run and assert the proper working of the tokenizer.
     */
    tokenize(): InputToken[];
    /**
     * 4.3.1. Consume a token
     * https://www.w3.org/TR/css-syntax-3/#consume-a-token
     */
    private consumeAToken;
    private consumeADelimToken;
    private consumeAWhitespace;
    private consumeAHashToken;
    private consumeCDO;
    private consumeCDC;
    private consumeAMatchToken;
    /**
     * 4.3.2. Consume a numeric token
     * https://www.w3.org/TR/css-syntax-3/#consume-a-numeric-token
     */
    private consumeANumericToken;
    /**
     * 4.3.3. Consume an ident-like token
     * https://www.w3.org/TR/css-syntax-3/#consume-an-ident-like-token
     */
    private consumeAnIdentLikeToken;
    /**
     * 4.3.4. Consume a string token
     * https://www.w3.org/TR/css-syntax-3/#consume-a-string-token
     */
    private consumeAStringToken;
    /**
     * 4.3.5. Consume a url token
     * https://www.w3.org/TR/css-syntax-3/#consume-a-url-token
     */
    private consumeAURLToken;
    /**
     * 4.3.11. Consume a name
     * https://www.w3.org/TR/css-syntax-3/#consume-a-name
     */
    private consumeAName;
    private consumeAtKeyword;
    private consumeAComment;
    private reconsumeTheCurrentInputToken;
    /**
     * 5.3.1. Parse a stylesheet
     * https://www.w3.org/TR/css-syntax-3/#parse-a-stylesheet
     */
    parseAStylesheet(): Stylesheet;
    /**
     * 5.4.1. Consume a list of rules
     * https://www.w3.org/TR/css-syntax-3/#consume-a-list-of-rules
     */
    consumeAListOfRules(): Rule[];
    /**
     * 5.4.2. Consume an at-rule
     * https://www.w3.org/TR/css-syntax-3/#consume-an-at-rule
     */
    consumeAnAtRule(): AtRule;
    /**
     * 5.4.3. Consume a qualified rule
     * https://www.w3.org/TR/css-syntax-3/#consume-a-qualified-rule
     */
    consumeAQualifiedRule(): QualifiedRule;
    /**
     * 5.4.6. Consume a component value
     * https://www.w3.org/TR/css-syntax-3/#consume-a-component-value
     */
    private consumeAComponentValue;
    /**
     * 5.4.7. Consume a simple block
     * https://www.w3.org/TR/css-syntax-3/#consume-a-simple-block
     */
    private consumeASimpleBlock;
    /**
     * 5.4.8. Consume a function
     * https://www.w3.org/TR/css-syntax-3/#consume-a-function
     */
    private consumeAFunction;
}
/**
 * Consume a CSS3 parsed stylesheet and convert the rules and selectors to the
 * NativeScript internal JSON representation.
 */
export declare class CSSNativeScript {
    parseStylesheet(stylesheet: Stylesheet): any;
    private parseRules;
    private parseRule;
    private parseAtRule;
    private parseQualifiedRule;
    private ruleBlockToDeclarations;
    private preludeToSelectorsStringArray;
}
export {};
